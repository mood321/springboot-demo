### SpringBoot-Redisson

````
分布式系统有一个著名的理论CAP，指在一个分布式系统中，最多只能同时满足一致性（Consistency）、
可用性（Availability）和分区容错性（Partition tolerance）这三项中的两项。所以在设计系统时，
往往需要权衡，在CAP中作选择。当然，这个理论也并不一定完美，不同系统对CAP的要求级别不一样，
选择需要考虑方方面面。

在微服务系统中，一个请求存在多级跨服务调用，往往需要牺牲强一致性老保证系统高可用，
比如通过分布式事务，异步消息等手段完成。但还是有的场景，需要阻塞所有节点的所有线程，对共享资源的访问。
比如并发时“超卖”和“余额减为负数”等情况。

本地锁可以通过语言本身支持，要实现分布式锁，就必须依赖中间件，数据库、redis、zookeeper等。
````
- 分布式锁特性
    ````
    1 互斥：互斥好像是必须的，否则怎么叫锁。
    2 死锁: 如果一个线程获得锁，然后挂了，并没有释放锁，致使其他节点(线程)永远无法获取锁，这就是死锁。分布式锁必须做到避免死锁。
    3 性能: 高并发分布式系统中，线程互斥等待会成为性能瓶颈，需要好的中间件和实现来保证性能。
    4 锁特性：考虑到复杂的场景，分布式锁不能只是加锁，然后一直等待。最好实现如Java Lock的一些功能如：锁判断，超时设置，可重入性等
    ````
- 分布式锁特性
    ````
    1 互斥：互斥好像是必须的，否则怎么叫锁。
    2 死锁: 如果一个线程获得锁，然后挂了，并没有释放锁，致使其他节点(线程)永远无法获取锁，这就是死锁。分布式锁必须做到避免死锁。
    3 性能: 高并发分布式系统中，线程互斥等待会成为性能瓶颈，需要好的中间件和实现来保证性能。
    4 锁特性：考虑到复杂的场景，分布式锁不能只是加锁，然后一直等待。最好实现如Java Lock的一些功能如：锁判断，超时设置，可重入性等
    ````
- Redis实现之Redisson原理
    ````
    redission实现了JDK中的Lock接口，所以使用方式一样，只是Redssion的锁是分布式的
        RLock lock = redisson.getLock("className");
        lock.lock();
        try {
        // do sth.
        } finally {
        lock.unlock();
        }
    ````
    - 获取锁流程
        ````
        　  1、判断有没有一个叫“abc”的key
        
        　　2、如果没有，则在其下设置一个字段为“6f0829ed-bfd3-4e6f-bba3-6f3d66cd176c:Thread-1”，值为“1”的键值对 ，并设置它的过期时间
        
        　　3、如果存在，则进一步判断“6f0829ed-bfd3-4e6f-bba3-6f3d66cd176c:Thread-1”是否存在，若存在，则其值加1，并重新设置过期时间
        
        　　4、返回“abc”的生存时间（毫秒）
        ````
    - 释放锁流程
        ````
        　   1、判断是否存在一个叫“abc”的key
         
         　　2、如果不存在，向Channel中广播一条消息，广播的内容是0，并返回1
         
         　　3、如果存在，进一步判断字段6f0829ed-bfd3-4e6f-bba3-6f3d66cd176c:Thread-1是否存在
         
         　　4、若字段不存在，返回空，若字段存在，则字段值减1
         
         　　5、若减完以后，字段值仍大于0，则返回0
         
         　　6、减完后，若字段值小于或等于0，则广播一条消息，广播内容是0，并返回1；
         
         可以猜测，广播0表示资源可用，即通知那些等待获取锁的线程现在可以获得锁了
        ````
        ![](https://img2018.cnblogs.com/blog/755840/201904/755840-20190424182315109-1747892333.png)
